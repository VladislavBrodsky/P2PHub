import { useMemo as Io, useSyncExternalStore as Oo } from "react";
class z extends Error {
  constructor(t, n, r) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, z.prototype);
  }
}
function Gn(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
function Do(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
const xo = "ERR_INVALID_VALUE", Mo = "ERR_UNEXPECTED_VALUE", jo = "ERR_UNEXPECTED_TYPE", Jn = "ERR_PARSE";
function Yn(e, t) {
  const n = {};
  for (const r in e) {
    const o = e[r];
    if (!o)
      continue;
    let s, a;
    typeof o == "function" ? (s = r, a = o) : [s, a] = o;
    try {
      const i = a(t(s));
      i !== void 0 && (n[r] = i);
    } catch (i) {
      throw new z(
        Jn,
        `Parser for "${r}" property failed${s === r ? "" : `. Source field: "${s}"`}`,
        i
      );
    }
  }
  return n;
}
function Qn(e) {
  let t = e;
  if (typeof t == "string")
    try {
      t = JSON.parse(t);
    } catch (n) {
      throw new z(xo, { cause: n });
    }
  if (typeof t != "object" || !t || Array.isArray(t))
    throw new z(Mo);
  return t;
}
function q(e, t) {
  return (n) => {
    const r = (o) => {
      if (!(n && o === void 0))
        try {
          return t(o);
        } catch (s) {
          throw new z(Jn, {
            message: `"${e}" transformer failed to parse the value`,
            cause: s
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      r,
      {
        isValid(o) {
          try {
            return r(o), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function Ue(e, t) {
  return q(t || "object", (n) => {
    const r = Qn(n);
    return Yn(e, (o) => r[o]);
  });
}
function Re(e) {
  throw new z(jo, `Unexpected value received: ${JSON.stringify(e)}`);
}
const Lo = q("boolean", (e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  Re(e);
}), N = q("string", (e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  Re(e);
}), $e = q("number", (e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  Re(e);
}), Mt = q("date", (e) => e instanceof Date ? e : new Date($e()(e) * 1e3));
function Kn(e, t) {
  return q(t || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && Re(n);
    const r = typeof n == "string" ? new URLSearchParams(n) : n;
    return Yn(e, (o) => {
      const s = r.get(o);
      return s === null ? void 0 : s;
    });
  });
}
function mt(e) {
  for (const t in e)
    e[t] = [Gn(t), e[t]];
  return e;
}
const Vo = (e) => {
  const t = $e(), n = $e(!0), r = N(), o = N(!0), s = Lo(!0), a = Ue(mt({
    addedToAttachmentMenu: s,
    allowsWriteToPm: s,
    firstName: r,
    id: t,
    isBot: s,
    isPremium: s,
    languageCode: o,
    lastName: o,
    photoUrl: o,
    username: o
  }), "User")(!0);
  return Kn(
    mt({
      authDate: Mt(),
      canSendAfter: n,
      chat: Ue(
        mt({
          id: t,
          type: r,
          title: r,
          photoUrl: o,
          username: o
        }),
        "Chat"
      )(!0),
      chatInstance: o,
      chatType: o,
      hash: r,
      queryId: o,
      receiver: a,
      startParam: o,
      signature: r,
      user: a
    }),
    "initData"
  )(e);
};
function _e(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function No(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Zn(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (_e(t))
    return t;
  if (No(t)) {
    let r = "#";
    for (let o = 0; o < 3; o += 1)
      r += t[1 + o].repeat(2);
    return r;
  }
  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((r, o) => {
    const s = parseInt(o, 10).toString(16);
    return r + (s.length === 1 ? "0" : "") + s;
  }, "#");
}
const qo = q("rgb", (e) => Zn(N()(e))), Uo = q(
  "themeParams",
  (e) => {
    const t = qo(!0);
    return Object.entries(Qn(e)).reduce((n, [r, o]) => (n[Do(r)] = t(o), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function Cn(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, n]) => [Gn(t), n])
    )
  );
}
// @__NO_SIDE_EFFECTS__
function jc(e) {
  const {
    initDataRaw: t,
    startParam: n,
    showSettings: r,
    botInline: o,
    fullscreen: s,
    defaultColors: a
  } = e, i = new URLSearchParams();
  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */ Cn(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof r == "boolean" && i.set("tgWebAppShowSettings", r ? "1" : "0"), typeof o == "boolean" && i.set("tgWebAppBotInline", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppFullscreen", s ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */ Cn(a)), i.toString();
}
function $o(e, t) {
  return q("array", (n) => {
    let r;
    if (Array.isArray(n))
      r = n;
    else if (typeof n == "string")
      try {
        const o = JSON.parse(n);
        Array.isArray(o) && (r = o);
      } catch {
      }
    return r || Re(n), r.map(e);
  });
}
function Xn(e) {
  return !!e && typeof e == "object" && !Array.isArray(e);
}
function Et(...e) {
  return e.map((t) => {
    if (typeof t == "string")
      return t;
    if (Xn(t))
      return Et(Object.entries(t).map((n) => n[1] && n[0]));
    if (Array.isArray(t))
      return Et(...t);
  }).filter(Boolean).join(" ");
}
function Lc(...e) {
  return e.reduce((t, n) => (Xn(n) && Object.entries(n).forEach(([r, o]) => {
    const s = Et(t[r], o);
    s && (t[r] = s);
  }), t), {});
}
class G extends Error {
  constructor(t, n, r) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, G.prototype);
  }
}
function er(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
function Fo(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
const Ho = "ERR_INVALID_VALUE", Wo = "ERR_UNEXPECTED_VALUE", zo = "ERR_UNEXPECTED_TYPE", tr = "ERR_PARSE";
function nr(e, t) {
  const n = {};
  for (const r in e) {
    const o = e[r];
    if (!o)
      continue;
    let s, a;
    typeof o == "function" ? (s = r, a = o) : [s, a] = o;
    try {
      const i = a(t(s));
      i !== void 0 && (n[r] = i);
    } catch (i) {
      throw new G(
        tr,
        `Parser for "${r}" property failed${s === r ? "" : `. Source field: "${s}"`}`,
        i
      );
    }
  }
  return n;
}
function rr(e) {
  let t = e;
  if (typeof t == "string")
    try {
      t = JSON.parse(t);
    } catch (n) {
      throw new G(Ho, { cause: n });
    }
  if (typeof t != "object" || !t || Array.isArray(t))
    throw new G(Wo);
  return t;
}
function D(e, t) {
  return (n) => {
    const r = (o) => {
      if (!(n && o === void 0))
        try {
          return t(o);
        } catch (s) {
          throw new G(tr, {
            message: `"${e}" transformer failed to parse the value`,
            cause: s
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      r,
      {
        isValid(o) {
          try {
            return r(o), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function O(e, t) {
  return D(t || "object", (n) => {
    const r = rr(n);
    return nr(e, (o) => r[o]);
  });
}
function Te(e) {
  throw new G(zo, `Unexpected value received: ${JSON.stringify(e)}`);
}
const Fe = D("boolean", (e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  Te(e);
}), B = D("string", (e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  Te(e);
}), fe = D("number", (e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  Te(e);
}), Go = D("date", (e) => e instanceof Date ? e : new Date(fe()(e) * 1e3));
function or(e, t) {
  return D(t || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && Te(n);
    const r = typeof n == "string" ? new URLSearchParams(n) : n;
    return nr(e, (o) => {
      const s = r.get(o);
      return s === null ? void 0 : s;
    });
  });
}
function ht(e) {
  for (const t in e)
    e[t] = [er(t), e[t]];
  return e;
}
const Jo = (e) => {
  const t = fe(), n = fe(!0), r = B(), o = B(!0), s = Fe(!0), a = O(ht({
    addedToAttachmentMenu: s,
    allowsWriteToPm: s,
    firstName: r,
    id: t,
    isBot: s,
    isPremium: s,
    languageCode: o,
    lastName: o,
    photoUrl: o,
    username: o
  }), "User")(!0);
  return or(
    ht({
      authDate: Go(),
      canSendAfter: n,
      chat: O(
        ht({
          id: t,
          type: r,
          title: r,
          photoUrl: o,
          username: o
        }),
        "Chat"
      )(!0),
      chatInstance: o,
      chatType: o,
      hash: r,
      queryId: o,
      receiver: a,
      startParam: o,
      signature: r,
      user: a
    }),
    "initData"
  )(e);
};
function Yo(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function Qo(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Ko(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (Yo(t))
    return t;
  if (Qo(t)) {
    let r = "#";
    for (let o = 0; o < 3; o += 1)
      r += t[1 + o].repeat(2);
    return r;
  }
  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((r, o) => {
    const s = parseInt(o, 10).toString(16);
    return r + (s.length === 1 ? "0" : "") + s;
  }, "#");
}
const Zo = D("rgb", (e) => Ko(B()(e))), Rn = D(
  "themeParams",
  (e) => {
    const t = Zo(!0);
    return Object.entries(rr(e)).reduce((n, [r, o]) => (n[Fo(r)] = t(o), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function vt(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, n]) => [er(t), n])
    )
  );
}
const Xo = (e) => {
  const t = B(), n = B(!0), r = Fe(!0);
  return or({
    botInline: ["tgWebAppBotInline", r],
    defaultColors: ["tgWebAppDefaultColors", Rn(!0)],
    fullscreen: ["tgWebAppFullscreen", r],
    initData: ["tgWebAppData", Jo(!0)],
    initDataRaw: ["tgWebAppData", n],
    platform: ["tgWebAppPlatform", t],
    showSettings: ["tgWebAppShowSettings", r],
    startParam: ["tgWebAppStartParam", n],
    themeParams: ["tgWebAppThemeParams", Rn()],
    version: ["tgWebAppVersion", t]
  }, "launchParams")(e);
};
// @__NO_SIDE_EFFECTS__
function es(e) {
  const {
    initDataRaw: t,
    startParam: n,
    showSettings: r,
    botInline: o,
    fullscreen: s,
    defaultColors: a
  } = e, i = new URLSearchParams();
  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */ vt(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof r == "boolean" && i.set("tgWebAppShowSettings", r ? "1" : "0"), typeof o == "boolean" && i.set("tgWebAppBotInline", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppFullscreen", s ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */ vt(a)), i.toString();
}
const sr = O({
  eventType: B(),
  eventData: (e) => e
}, "miniAppsMessage"), ar = D("fn", (e) => {
  if (typeof e == "function")
    return e;
  Te(e);
});
function ts(e) {
  return !!e && typeof e == "object" && !Array.isArray(e);
}
const ns = O({
  TelegramWebviewProxy: O({ postEvent: ar() })()
});
function ir(e) {
  return ns().isValid(e);
}
function rs() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
var os = Object.defineProperty, ss = (e, t, n) => t in e ? os(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, cr = (e, t, n) => ss(e, typeof t != "symbol" ? t + "" : t, n);
let p = class ur extends Error {
  constructor(t, n, r) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, ur.prototype);
  }
};
function pr(e, t, n) {
  return e.addEventListener(t, n), () => e.removeEventListener(t, n);
}
function ne(...e) {
  const t = e.flat(1);
  return [
    t.push.bind(t),
    () => {
      t.forEach((n) => {
        n();
      });
    }
  ];
}
function as(e, t) {
  return e instanceof p && e.type === t;
}
function jt(e) {
  return (t) => as(t, e);
}
const lr = "ERR_ABORTED", dr = "ERR_CANCELED", _r = "ERR_TIMED_OUT";
function Tn(e) {
  return new p(lr, { cause: e });
}
const Vc = jt(_r), Nc = jt(lr), qc = jt(dr);
function Bn(e, t) {
  return e.reject = t.reject, e;
}
class b extends Promise {
  constructor(t, n) {
    let r, o;
    typeof t == "function" ? (r = t, o = n) : o = t;
    let s, a;
    super((i, l) => {
      o || (o = {});
      const { abortSignal: u } = o;
      if (u && u.aborted)
        return l(Tn(u.reason));
      const [f, y] = ne(), v = (m) => (...W) => (y(), m(...W)), L = new AbortController(), { signal: R } = L;
      a = v((m) => {
        L.abort(m), l(m);
      }), s = v(i), u && f(
        pr(u, "abort", () => {
          a(Tn(u.reason));
        })
      );
      const { timeout: g } = o;
      if (g) {
        const m = setTimeout(() => {
          a(new p(_r, `Timeout reached: ${g}ms`));
        }, g);
        f(() => {
          clearTimeout(m);
        });
      }
      r && r(s, a, R);
    }), cr(this, "reject"), this.reject = a;
  }
  /**
   * Creates a new BetterPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(t, n) {
    return new b((r, o, s) => {
      try {
        const a = t(s);
        return a instanceof Promise ? a.then(r, o) : r(a);
      } catch (a) {
        o(a);
      }
    }, n);
  }
  /**
   * @see Promise.resolve
   */
  static resolve(t) {
    return new b((n) => {
      n(t);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(t) {
    return new b((n, r) => {
      r(t);
    });
  }
  /**
   * Cancels the promise execution.
   */
  cancel() {
    this.reject(new p(dr));
  }
  /**
   * @see Promise.catch
   */
  catch(t) {
    return this.then(void 0, t);
  }
  /**
   * @see Promise.finally
   */
  finally(t) {
    return Bn(super.finally(t), this);
  }
  /**
   * @see Promise.then
   */
  then(t, n) {
    return Bn(super.then(t, n), this);
  }
}
function Pn(e, t) {
  return e.resolve = t.resolve, e;
}
let is = class Oe extends b {
  constructor(t, n) {
    let r, o;
    typeof t == "function" ? (r = t, o = n) : o = t;
    let s;
    super((a, i, l) => {
      s = a, r && r(a, i, l);
    }, o), cr(this, "resolve"), this.resolve = s;
  }
  /**
   * Creates a new EnhancedPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(t, n) {
    return new Oe(
      (r, o, s) => b.withFn(t, { abortSignal: s }).then(r, o),
      n
    );
  }
  /**
   * @see Promise.resolve
   */
  static resolve(t) {
    return new Oe((n) => {
      n(t);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(t) {
    return new Oe((n, r) => {
      r(t);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(t) {
    return this.then(void 0, t);
  }
  /**
   * @see Promise.finally
   */
  finally(t) {
    return Pn(super.finally(t), this);
  }
  /**
   * @see Promise.then
   */
  then(t, n) {
    return Pn(super.then(t, n), this);
  }
};
function cs(e, t) {
  return new b((n) => {
    setTimeout(n, e);
  }, { abortSignal: t });
}
function fr(e) {
  return `tapps/${e}`;
}
function P(e, t) {
  sessionStorage.setItem(fr(e), JSON.stringify(t));
}
function k(e) {
  const t = sessionStorage.getItem(fr(e));
  try {
    return t ? JSON.parse(t) : void 0;
  } catch {
  }
}
function Lt(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
// @__NO_SIDE_EFFECTS__
function us(e, t) {
  t || (t = {});
  const {
    textColor: n,
    bgColor: r,
    shouldLog: o = !0
  } = t;
  function s(a, ...i) {
    if (!o || typeof o == "function" && !o())
      return;
    const l = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[a](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${e}`,
      `${l};background-color: lightblue;color:black`,
      "",
      `${l};${n ? `color:${n};` : ""}${r ? `background-color:${r}` : ""}`,
      ...i
    );
  }
  return [
    function(...a) {
      s("log", ...a);
    },
    function(...a) {
      s("error", ...a);
    }
  ];
}
function Vt(e, t) {
  document.documentElement.style.setProperty(e, t);
}
function Nt(e) {
  document.documentElement.style.removeProperty(e);
}
function ps(e, t) {
  t();
}
// @__NO_SIDE_EFFECTS__
function re(e, t) {
  t || (t = {});
  const n = t.equals || Object.is;
  let r = [], o = e;
  const s = (u) => {
    if (!n(o, u)) {
      const f = o;
      o = u, ps(l, () => {
        [...r].forEach(([y, v]) => {
          y(u, f), v && i(y, !0);
        });
      });
    }
  };
  function a(u) {
    const f = typeof u != "object" ? { once: u } : u;
    return {
      once: f.once || !1,
      signal: f.signal || !1
    };
  }
  const i = (u, f) => {
    const y = a(f), v = r.findIndex(([L, R]) => L === u && R.once === y.once && R.signal === y.signal);
    v >= 0 && r.splice(v, 1);
  }, l = Object.assign(
    function() {
      return ls(l), o;
    },
    {
      destroy() {
        r = [];
      },
      set: s,
      reset() {
        s(e);
      },
      sub(u, f) {
        return r.push([u, a(f)]), () => i(u, f);
      },
      unsub: i,
      unsubAll() {
        r = r.filter((u) => u[1].signal);
      }
    }
  );
  return l;
}
const bt = [];
function ls(e) {
  bt.length && bt[bt.length - 1].add(e);
}
const ds = /* @__PURE__ */ re(!1), [qt, _s] = /* @__PURE__ */ us("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: ds
}), fs = {
  clipboard_text_received: O({
    req_id: B(),
    data: (e) => e === null ? e : B(!0)(e)
  }, "clipboard_text_received"),
  custom_method_invoked: O({
    req_id: B(),
    result: (e) => e,
    error: B(!0)
  }, "custom_method_invoked"),
  popup_closed: D("popup_closed", (e) => e ? O({
    button_id: (t) => t == null ? void 0 : B()(t)
  })()(e) : {}),
  viewport_changed: O({
    height: fe(),
    width: (e) => e == null ? window.innerWidth : fe()(e),
    is_state_stable: Fe(),
    is_expanded: Fe()
  }, "viewport_changed")
};
function ms(e) {
  const t = window, [, n] = ne(
    // Add listener, which handles events sent from the Telegram web application and also events
    // generated by the local emitEvent function.
    pr(t, "message", (r) => {
      if (r.source !== t.parent)
        return;
      let o;
      try {
        o = sr()(r.data);
      } catch {
        return;
      }
      const { eventType: s, eventData: a } = o, i = fs[s];
      try {
        const l = i ? i()(a) : a;
        qt("Event received:", l ? { eventType: s, eventData: l } : { eventType: s }), e([s, l]);
      } catch (l) {
        _s(
          [
            `An error occurred processing the "${s}" event from the Telegram application.`,
            "Please, file an issue here:",
            "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
          ].join(`
`),
          o,
          l
        );
      }
    })
  );
  return n;
}
const At = /* @__PURE__ */ re(), kn = /* @__PURE__ */ re();
function mr() {
  return kn() || kn.set(ms(At.set)), At;
}
const gt = /* @__PURE__ */ re({});
function hr(e) {
  let t = gt()[e];
  return t || (t = /* @__PURE__ */ re(void 0, {
    equals() {
      return !1;
    }
  }), mr().sub((n) => {
    n && n[0] === e && t.set(n[1]);
  }), gt.set({ ...gt(), [e]: t })), t;
}
function w(e, t, n) {
  return hr(e).sub(t, n);
}
const hs = "ERR_METHOD_UNSUPPORTED", bs = "ERR_RETRIEVE_LP_FAILED", gs = "ERR_METHOD_PARAMETER_UNSUPPORTED", br = "ERR_UNKNOWN_ENV", ws = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE", ys = /* @__PURE__ */ re("https://web.telegram.org");
function Ut(e, t) {
  qt("Posting event:", t ? { eventType: e, eventData: t } : { eventType: e });
  const n = window;
  if (ir(n)) {
    n.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));
    return;
  }
  const r = JSON.stringify({ eventType: e, eventData: t });
  if (rs())
    return n.parent.postMessage(r, ys());
  const { external: o } = n;
  if (O({ notify: ar() })().isValid(o)) {
    o.notify(r);
    return;
  }
  throw new p(br);
}
function $t(e, t, n) {
  n || (n = {});
  const { capture: r } = n, [o, s] = ne();
  return new b((a) => {
    (Array.isArray(t) ? t : [t]).forEach((i) => {
      o(
        w(i, (l) => {
          (!r || (Array.isArray(t) ? r({
            event: i,
            payload: l
          }) : r(l))) && a(l);
        })
      );
    }), (n.postEvent || Ut)(e, n.params);
  }, n).finally(s);
}
function Ft(e) {
  return Xo()(e);
}
function gr(e) {
  return Ft(
    e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&")
  );
}
function Ss() {
  return gr(window.location.href);
}
function Es() {
  const e = performance.getEntriesByType("navigation")[0];
  if (!e)
    throw new Error("Unable to get first navigation entry.");
  return gr(e.name);
}
const vs = "launchParams";
function As() {
  return Ft(k(vs) || "");
}
function wr(e) {
  P("launchParams", /* @__PURE__ */ es(e));
}
function yr(e) {
  return e instanceof Error ? e.message + (e.cause ? `
  ${yr(e.cause)}` : "") : JSON.stringify(e);
}
function Y() {
  const e = [];
  for (const t of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    Ss,
    // Then, try using the lower level API - window.performance.
    Es,
    // Finally, try to extract launch parameters from the session storage.
    As
  ])
    try {
      const n = t();
      return wr(n), n;
    } catch (n) {
      e.push(n);
    }
  throw new p(bs, [
    "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
    "ðŸ“– Refer to docs for more information:",
    "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment",
    "Collected errors:",
    ...e.map((t) => `â€” ${yr(t)}`)
  ].join(`
`));
}
function In(e) {
  if (e === "simple")
    try {
      return Y(), !0;
    } catch {
      return !1;
    }
  return b.withFn(async () => {
    if (ir(window))
      return !0;
    try {
      return await $t("web_app_request_theme", "theme_changed", { timeout: 100 }), !0;
    } catch {
      return !1;
    }
  }, e);
}
function Ct(e, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
function Cs(e, t) {
  if (typeof t == "string")
    try {
      const { eventType: n } = sr()(t);
      n === "web_app_request_theme" && Ct("theme_changed", {
        theme_params: JSON.parse(/* @__PURE__ */ vt(e))
      }), n === "web_app_request_viewport" && Ct("viewport_changed", {
        width: window.innerWidth,
        height: window.innerHeight,
        is_state_stable: !0,
        is_expanded: !0
      });
    } catch {
    }
}
function Uc(e) {
  var t;
  const n = typeof e == "string" ? Ft(e) : e;
  wr(n);
  const r = (t = window.TelegramWebviewProxy) == null ? void 0 : t.postEvent;
  window.TelegramWebviewProxy = {
    postEvent(o, s) {
      Cs(n.themeParams, JSON.stringify({ eventType: o, eventData: s })), r == null || r(o, s);
    }
  }, qt("Environment was mocked by the mockTelegramEnv function");
}
function Rs() {
  [
    ["TelegramGameProxy_receiveEvent"],
    // Windows Phone.
    ["TelegramGameProxy", "receiveEvent"],
    // Desktop.
    ["Telegram", "WebView", "receiveEvent"]
    // Android and iOS.
  ].forEach((e) => {
    let t = window;
    e.forEach((n, r, o) => {
      if (r === o.length - 1) {
        t[n] = Ct;
        return;
      }
      n in t || (t[n] = {}), t = t[n];
    });
  });
}
function Ts() {
  ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((e) => {
    delete window[e];
  });
}
function C(e, t, n) {
  hr(e).unsub(t, n);
}
function $c(e, t) {
  return mr().sub(e, t);
}
function Fc(e, t) {
  At.unsub(e, t);
}
function Sr(e) {
  return ({ req_id: t }) => t === e;
}
function On(e) {
  return e.split(".").map(Number);
}
function Bs(e, t) {
  const n = On(e), r = On(t), o = Math.max(n.length, r.length);
  for (let s = 0; s < o; s += 1) {
    const a = n[s] || 0, i = r[s] || 0;
    if (a !== i)
      return a > i ? 1 : -1;
  }
  return 0;
}
function S(e, t) {
  return Bs(e, t) <= 0;
}
function J(e, t, n) {
  if (typeof n == "string") {
    if (e === "web_app_open_link") {
      if (t === "try_instant_view")
        return S("6.4", n);
      if (t === "try_browser")
        return S("7.6", n);
    }
    if (e === "web_app_set_header_color" && t === "color")
      return S("6.9", n);
    if (e === "web_app_close" && t === "return_back")
      return S("7.6", n);
    if (e === "web_app_setup_main_button" && t === "has_shine_effect")
      return S("7.10", n);
  }
  switch (e) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return S("6.1", t);
    case "web_app_open_popup":
      return S("6.2", t);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return S("6.4", t);
    case "web_app_switch_inline_query":
      return S("6.7", t);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return S("6.9", t);
    case "web_app_setup_settings_button":
      return S("6.10", t);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return S("7.2", t);
    case "web_app_setup_swipe_behavior":
      return S("7.7", t);
    case "web_app_share_to_story":
      return S("7.8", t);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
      return S("7.10", t);
    case "web_app_request_safe_area":
    case "web_app_request_content_safe_area":
    case "web_app_request_fullscreen":
    case "web_app_exit_fullscreen":
    case "web_app_set_emoji_status":
    case "web_app_add_to_home_screen":
    case "web_app_check_home_screen":
    case "web_app_request_emoji_status_access":
      return S("8.0", t);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(e);
  }
}
function Ps(e, t) {
  t || (t = "strict");
  const n = typeof t == "function" ? t : (r) => {
    const { method: o, version: s } = r;
    let a, i;
    if ("param" in r ? (a = `Parameter "${r.param}" of "${o}" method is unsupported in Mini Apps version ${s}`, i = gs) : (a = `Method "${o}" is unsupported in Mini Apps version ${s}`, i = hs), t === "strict")
      throw new p(i, a);
    return console.warn(a);
  };
  return (r, o) => J(r, e) ? ts(o) && r === "web_app_set_header_color" && "color" in o && !J(r, "color", e) ? n({ version: e, method: r, param: "color" }) : Ut(r, o) : n({ version: e, method: r });
}
function ks(e, t, n, r) {
  return $t("web_app_invoke_custom_method", "custom_method_invoked", {
    ...r || {},
    params: { method: e, params: t, req_id: n },
    capture: Sr(n)
  }).then(({ result: o, error: s }) => {
    if (s)
      throw new p(ws, s);
    return o;
  });
}
function Is() {
  return performance.getEntriesByType("navigation")[0];
}
function x() {
  const e = Is();
  return !!e && e.type === "reload";
}
let X;
function Os(e, t) {
  X && X.set(e, t) || t();
}
function Rt(e) {
  if (X)
    return e();
  X = /* @__PURE__ */ new Map();
  try {
    e();
  } finally {
    X.forEach((t) => t()), X = void 0;
  }
}
// @__NO_SIDE_EFFECTS__
function c(e, t) {
  t || (t = {});
  const n = t.equals || Object.is;
  let r = [], o = e;
  const s = (u) => {
    if (!n(o, u)) {
      const f = o;
      o = u, Os(l, () => {
        [...r].forEach(([y, v]) => {
          y(u, f), v && i(y, !0);
        });
      });
    }
  };
  function a(u) {
    const f = typeof u != "object" ? { once: u } : u;
    return {
      once: f.once || !1,
      signal: f.signal || !1
    };
  }
  const i = (u, f) => {
    const y = a(f), v = r.findIndex(([L, R]) => L === u && R.once === y.once && R.signal === y.signal);
    v >= 0 && r.splice(v, 1);
  }, l = Object.assign(
    function() {
      return Ds(l), o;
    },
    {
      destroy() {
        r = [];
      },
      set: s,
      reset() {
        s(e);
      },
      sub(u, f) {
        return r.push([u, a(f)]), () => i(u, f);
      },
      unsub: i,
      unsubAll() {
        r = r.filter((u) => u[1].signal);
      }
    }
  );
  return l;
}
const ue = [];
function Ds(e) {
  ue.length && ue[ue.length - 1].add(e);
}
// @__NO_SIDE_EFFECTS__
function d(e, t) {
  let n = /* @__PURE__ */ new Set(), r;
  function o() {
    return r || (r = /* @__PURE__ */ c(a(), t));
  }
  function s() {
    o().set(a());
  }
  function a() {
    n.forEach((u) => {
      u.unsub(s, { signal: !0 });
    });
    const i = /* @__PURE__ */ new Set();
    let l;
    ue.push(i);
    try {
      l = e();
    } finally {
      ue.pop();
    }
    return i.forEach((u) => {
      u.sub(s, { signal: !0 });
    }), n = i, l;
  }
  return Object.assign(function() {
    return o()();
  }, {
    destroy() {
      o().destroy();
    },
    sub(...i) {
      return o().sub(...i);
    },
    unsub(...i) {
      o().unsub(...i);
    },
    unsubAll(...i) {
      o().unsubAll(...i);
    }
  });
}
const xs = /* @__PURE__ */ c(/* @__PURE__ */ (() => {
  let e = 0;
  return () => (e += 1).toString();
})()), Er = /* @__PURE__ */ c(Ut), V = /* @__PURE__ */ c("0.0");
function Ms(e) {
  e || (e = {});
  const { postEvent: t } = e, n = e.version || Y().version;
  V.set(n), Er.set(
    typeof t == "function" ? t : Ps(n)
  );
}
function vr() {
  return xs()();
}
function oe(e, t, n) {
  return ks(e, t, vr(), {
    ...n || {},
    postEvent: _
  });
}
const E = (e, t, n) => (n || (n = {}), n.postEvent || (n.postEvent = _), $t(e, t, n)), _ = (e, t) => Er()(e, t);
function M(e) {
  return /* @__PURE__ */ d(() => J(e, V()));
}
const ce = "ERR_POPUP_INVALID_PARAMS", Ht = "ERR_INVALID_URL", js = "ERR_INVALID_SLUG", Ls = "ERR_DATA_INVALID_SIZE", Vs = "ERR_ACCESS_DENIED", F = "ERR_ALREADY_REQUESTING", Wt = "ERR_ALREADY_OPENED", Ns = "ERR_ALREADY_MOUNTING", qs = "ERR_VARS_ALREADY_BOUND", Us = "ERR_NOT_AVAILABLE", $s = "ERR_NOT_INITIALIZED", Dn = "ERR_NOT_SUPPORTED", Fs = "ERR_NOT_MOUNTED", Hs = "ERR_FULLSCREEN_FAILED", Ws = "ERR_EMOJI_STATUS_SET_FAILED";
function xn() {
  return typeof window > "u";
}
// @__NO_SIDE_EFFECTS__
function h(e, t, { isSupported: n, isMounted: r, component: o, supports: s } = {}) {
  const a = `${o ? `${o}.` : ""}${e}()`;
  n = n ? Array.isArray(n) || typeof n == "object" && "any" in n ? n : [n] : void 0;
  function i(g) {
    if (s) {
      const m = s[g];
      return J(m[0], m[1], V());
    }
    return !0;
  }
  const l = () => {
    if (!n)
      return;
    const g = `it is unsupported in Mini Apps version ${V()}`;
    function m(T) {
      return typeof T == "string" ? J(T, V()) ? void 0 : g : T.fn() ? void 0 : T.error;
    }
    if (Array.isArray(n)) {
      for (const T of n) {
        const An = m(T);
        if (An)
          return An;
      }
      return;
    }
    let W;
    for (const T of n.any)
      if (W = m(T), !W)
        return;
    return g;
  }, u = (...g) => {
    if (s) {
      for (const m in s)
        if (s[m][2](...g) && !i(m))
          return `option ${m} is not supported in Mini Apps version ${V()}`;
    }
  }, f = /* @__PURE__ */ d(() => !l()), y = /* @__PURE__ */ d(() => V() !== "0.0"), v = /* @__PURE__ */ d(() => !r || r()), L = /* @__PURE__ */ d(
    () => In("simple") && !xn() && y() && f() && v()
  );
  let R;
  if (s) {
    R = {};
    for (const g in s)
      R[g] = /* @__PURE__ */ d(() => i(g));
  }
  return Object.assign(
    (...g) => {
      const m = `Unable to call the ${a} ${o ? "method" : "function"}:`;
      if (xn() || !In("simple"))
        throw new p(
          br,
          `${m} it can't be called outside Mini Apps`
        );
      if (!y())
        throw new p(
          $s,
          `${m} the SDK was not initialized. Use the SDK init() function`
        );
      const W = l();
      if (W)
        throw new p(Dn, `${m} ${W}`);
      const T = u(...g);
      if (T)
        throw new p(Dn, `${m} ${T}`);
      if (!v())
        throw new p(
          Fs,
          `${m} the component is not mounted. Use the ${o}.mount() method`
        );
      return t(...g);
    },
    t,
    {
      isAvailable: L,
      ifAvailable(...g) {
        return L() ? t(...g) : void 0;
      }
    },
    n ? {
      isSupported: f
    } : {},
    R ? {
      supports: R
    } : {}
  );
}
function We(e, t) {
  return t || (t = {}), (n, r, o, s) => /* @__PURE__ */ h(n, r, {
    ...t,
    isSupported: o || t.isSupported,
    supports: s,
    component: e
  });
}
function Q(e, t, n) {
  return We(e, { isSupported: n, isMounted: t });
}
function I(e, t) {
  return We(e, { isSupported: t });
}
const ze = "web_app_setup_back_button", Ar = "back_button_pressed", Ge = "backButton", Tt = /* @__PURE__ */ c(!1), me = /* @__PURE__ */ c(!1), zs = M(ze), Cr = Q(Ge, me, ze), zt = I(Ge, ze), Gs = Cr("hide", () => {
  Gt(!1);
}), Js = zt("mount", () => {
  me() || (Gt(x() && k(Ge) || !1), me.set(!0));
});
function Gt(e) {
  e !== Tt() && (_(ze, { is_visible: e }), P(Ge, e), Tt.set(e));
}
const Ys = zt(
  "onClick",
  (e) => w(Ar, e)
), Qs = zt(
  "offClick",
  (e) => {
    C(Ar, e);
  }
), Ks = Cr("show", () => {
  Gt(!0);
});
function Zs() {
  me.set(!1);
}
const Hc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: Gs,
  isMounted: me,
  isSupported: zs,
  isVisible: Tt,
  mount: Js,
  offClick: Qs,
  onClick: Ys,
  show: Ks,
  unmount: Zs
}, Symbol.toStringTag, { value: "Module" }));
// @__NO_SIDE_EFFECTS__
function Be(e, t, n, r, o) {
  const s = o === void 0 || o ? b : Promise;
  return Object.assign((...a) => s.resolve().then(async () => {
    if (n()) {
      const l = t();
      throw r.set(l), l;
    }
    Rt(() => {
      n.set(
        s.resolve(e(...a))
      ), r.set(void 0);
    });
    let i;
    try {
      i = [!0, await n()];
    } catch (l) {
      i = [!1, l];
    }
    if (Rt(() => {
      n.set(void 0), r.set(i[0] ? void 0 : i[1]);
    }), !i[0])
      throw i[1];
    return i[1];
  }), e);
}
// @__NO_SIDE_EFFECTS__
function Rr(e, t, n, r, o, s) {
  const a = /* @__PURE__ */ Be(
    t,
    () => new p(
      Ns,
      `The ${e} component is already mounting`
    ),
    o,
    s
  );
  return (i) => b.resolve().then(async () => {
    if (!r()) {
      const l = await a(i);
      Rt(() => {
        r.set(!0), n(l);
      });
    }
  });
}
const U = We, Je = /* @__PURE__ */ c({ available: !1 }), De = /* @__PURE__ */ c(!1), xe = /* @__PURE__ */ c(!1), Ye = /* @__PURE__ */ c(!1), Xs = /* @__PURE__ */ d(() => !!Jt()), Tr = /* @__PURE__ */ c(), Jt = /* @__PURE__ */ c(), ea = /* @__PURE__ */ d(() => {
  const e = Je();
  return e && e.available;
});
function Yt(e) {
  return e.available ? {
    available: !0,
    tokenSaved: e.token_saved,
    deviceId: e.device_id,
    accessRequested: e.access_requested,
    type: e.type,
    accessGranted: e.access_granted
  } : {
    available: !1
  };
}
const Mn = "web_app_biometry_get_info", ta = /* @__PURE__ */ h(
  "requestBiometry",
  (e) => E(Mn, "biometry_info_received", e).then(Yt),
  {
    isSupported: Mn
  }
), Qe = "web_app_biometry_request_auth", na = "web_app_biometry_request_access", ra = "web_app_biometry_open_settings", oa = "web_app_biometry_update_token", Qt = "biometry_info_received", te = "biometry", sa = M(Qe), aa = U(te), ia = I(te, Qe), Kt = Q(te, Ye, Qe);
function Br() {
  throw new p(Us, "Biometry is not available");
}
const ca = Kt(
  "authenticate",
  (e) => b.withFn(async (t) => {
    if (De())
      throw new p(F, "Authentication is already in progress");
    const n = Je();
    (!n || !n.available) && Br(), De.set(!0);
    try {
      const r = await E(
        Qe,
        "biometry_auth_requested",
        {
          abortSignal: t,
          params: {
            reason: ((e || {}).reason || "").trim()
          }
        }
      ), { token: o } = r;
      return typeof o == "string" && Ke({ ...n, token: o }), r;
    } finally {
      De.set(!1);
    }
  }, e)
), ua = ia("openSettings", () => {
  _(ra);
}), pa = Kt(
  "requestAccess",
  (e) => b.withFn(async (t) => {
    if (xe())
      throw new p(F, "Access request is already in progress");
    xe.set(!0);
    try {
      const n = await E(na, Qt, {
        abortSignal: t,
        params: { reason: (e || {}).reason || "" }
      }).then(Yt);
      return n.available || Br(), Ke(n), n.accessGranted;
    } finally {
      xe.set(!1);
    }
  }, e)
), la = aa("mount", /* @__PURE__ */ Rr(
  te,
  (e) => x() && k(te) || ta(e),
  (e) => {
    w(Qt, Pr), Ke(e);
  },
  Ye,
  Jt,
  Tr
)), Pr = (e) => {
  Ke(Yt(e));
};
function Ke(e) {
  Je.set(e), P(te, e);
}
function da() {
  C(Qt, Pr), Ye.set(!1);
}
const _a = Kt(
  "updateToken",
  (e) => (e || (e = {}), E(oa, "biometry_token_updated", {
    ...e,
    params: {
      token: e.token || "",
      reason: e.reason
    }
  }).then((t) => t.status))
), Wc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authenticate: ca,
  isAuthenticating: De,
  isAvailable: ea,
  isMounted: Ye,
  isMounting: Xs,
  isRequestingAccess: xe,
  isSupported: sa,
  mount: la,
  mountError: Tr,
  mountPromise: Jt,
  openSettings: ua,
  requestAccess: pa,
  state: Je,
  unmount: da,
  updateToken: _a
}, Symbol.toStringTag, { value: "Module" }));
function Ze(e, t) {
  return We(e, { isMounted: t });
}
const Xe = "closingBehavior", Bt = /* @__PURE__ */ c(!1), he = /* @__PURE__ */ c(!1), kr = Ze(Xe, he), fa = U(Xe), ma = kr("disableConfirmation", () => {
  Zt(!1);
}), ha = kr("enableConfirmation", () => {
  Zt(!0);
}), ba = fa("mount", () => {
  he() || (Zt(
    x() && k(Xe) || !1
  ), he.set(!0));
});
function Zt(e) {
  e !== Bt() && (_("web_app_setup_closing_behavior", { need_confirmation: e }), P(Xe, e), Bt.set(e));
}
function ga() {
  he.set(!1);
}
const zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableConfirmation: ma,
  enableConfirmation: ha,
  isConfirmationEnabled: Bt,
  isMounted: he,
  mount: ba,
  unmount: ga
}, Symbol.toStringTag, { value: "Module" })), Ir = "web_app_invoke_custom_method", et = I("cloudStorage", Ir), wa = M(Ir), ya = et("deleteItem", (e, t) => {
  const n = Array.isArray(e) ? e : [e];
  return n.length ? oe("deleteStorageValues", { keys: n }, t).then() : b.resolve();
});
function Sa(e, t) {
  const n = Array.isArray(e) ? e : [e];
  return n.length ? oe("getStorageValues", { keys: n }, t).then((r) => {
    const o = Ue(
      Object.fromEntries(n.map((s) => [s, N()]))
    )()(r);
    return Array.isArray(e) ? o : o[e];
  }) : b.resolve(typeof e == "string" ? "" : {});
}
const Ea = et("getItem", Sa), va = et("getKeys", (e) => oe("getStorageKeys", {}, e).then($o(N())())), Aa = et("setItem", (e, t, n) => oe("saveStorageValue", {
  key: e,
  value: t
}, n).then()), Gc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  deleteItem: ya,
  getItem: Ea,
  getKeys: va,
  isSupported: wa,
  setItem: Aa
}, Symbol.toStringTag, { value: "Module" })), Pe = "web_app_trigger_haptic_feedback", Xt = I("hapticFeedback", Pe), Ca = M(Pe), Ra = Xt(
  "impactOccurred",
  (e) => {
    _(Pe, {
      type: "impact",
      impact_style: e
    });
  }
), Ta = Xt(
  "notificationOccurred",
  (e) => {
    _(Pe, {
      type: "notification",
      notification_type: e
    });
  }
), Ba = Xt(
  "selectionChanged",
  () => {
    _(Pe, { type: "selection_change" });
  }
), Jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  impactOccurred: Ra,
  isSupported: Ca,
  notificationOccurred: Ta,
  selectionChanged: Ba
}, Symbol.toStringTag, { value: "Module" })), en = /* @__PURE__ */ c(void 0);
function j(e) {
  return /* @__PURE__ */ d(() => {
    const t = en();
    return t ? t[e] : void 0;
  });
}
const Or = j("authDate"), Dr = j("canSendAfter"), Pa = /* @__PURE__ */ d(() => {
  const e = Or(), t = Dr();
  return t && e ? new Date(e.getTime() + t * 1e3) : void 0;
}), ka = j("chat"), Ia = j("chatType"), Oa = j("chatInstance"), Da = j("hash"), xa = j("queryId"), xr = /* @__PURE__ */ c(), Ma = j("receiver");
function ja() {
  const e = Y();
  en.set(e.initData), xr.set(e.initDataRaw);
}
const La = j("startParam"), Va = j("user"), Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authDate: Or,
  canSendAfter: Dr,
  canSendAfterDate: Pa,
  chat: ka,
  chatInstance: Oa,
  chatType: Ia,
  hash: Da,
  queryId: xa,
  raw: xr,
  receiver: Ma,
  restore: ja,
  startParam: La,
  state: en,
  user: Va
}, Symbol.toStringTag, { value: "Module" }));
function Qc(e) {
  return Vo()(e);
}
const tn = "web_app_open_invoice", Na = I("invoice", tn), Me = /* @__PURE__ */ c(!1), qa = M(tn);
async function Mr(e, t, n) {
  if (Me())
    throw new p(Wt, "An invoice is already opened");
  let r;
  if (t === "url") {
    const { hostname: o, pathname: s } = new URL(e, window.location.href);
    if (o !== "t.me")
      throw new p(Ht, `Link has unexpected hostname: ${o}`);
    const a = s.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new p(
        js,
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , r] = a;
  } else
    r = e, n = t;
  return Me.set(!0), E(tn, "invoice_closed", {
    ...n,
    params: { slug: r },
    capture: (o) => r === o.slug
  }).then((o) => o.status).finally(() => {
    Me.set(!1);
  });
}
const Ua = Na("open", Mr), Kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _open: Mr,
  isOpened: Me,
  isSupported: qa,
  open: Ua
}, Symbol.toStringTag, { value: "Module" }));
function jr(e) {
  return Object.fromEntries(
    Object.entries(e).filter((t) => t[1] !== void 0)
  );
}
function Lr(e) {
  const t = Zn(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((n, r, o) => {
      const s = parseInt(t.slice(1 + o * 2, 1 + (o + 1) * 2), 16);
      return n + s * s * r;
    }, 0)
  ) < 120;
}
const be = /* @__PURE__ */ c(!1), je = /* @__PURE__ */ c(!1), $ = /* @__PURE__ */ c({});
function A(e) {
  return /* @__PURE__ */ d(() => $()[e]);
}
const $a = A("accentTextColor"), nn = A("bgColor"), rn = A("buttonColor"), Vr = A("buttonTextColor"), Nr = A("bottomBarBgColor"), Fa = A("destructiveTextColor"), Ha = A("headerBgColor"), Wa = A("hintColor"), za = /* @__PURE__ */ d(() => {
  const { bgColor: e } = $();
  return !e || Lr(e);
}), Ga = A("linkColor"), He = A("secondaryBgColor"), Ja = A("sectionBgColor"), Ya = A("sectionHeaderTextColor"), Qa = A("sectionSeparatorColor"), Ka = A("subtitleTextColor"), Za = A("textColor");
function K(e) {
  return /* @__PURE__ */ d(() => on()[e]);
}
const pe = /* @__PURE__ */ c({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  text: "Continue"
}), on = /* @__PURE__ */ d(() => {
  const e = pe();
  return {
    ...e,
    backgroundColor: e.backgroundColor || rn() || "#2481cc",
    textColor: e.textColor || Vr() || "#ffffff"
  };
}), ge = /* @__PURE__ */ c(!1), Xa = K("backgroundColor"), ei = K("hasShineEffect"), ti = K("isEnabled"), ni = K("isLoaderVisible"), ri = K("isVisible"), oi = K("text"), si = K("textColor"), ai = "web_app_setup_main_button", qr = "main_button_pressed", tt = "mainButton", sn = U(tt), ii = Ze(tt, ge), ci = sn("mount", () => {
  if (!ge()) {
    const e = x() && k(tt);
    e && pe.set(e), ge.set(!0);
  }
}), ui = sn(
  "onClick",
  (e) => w(qr, e)
), pi = sn(
  "offClick",
  (e) => {
    C(qr, e);
  }
), li = ii(
  "setParams",
  (e) => {
    pe.set({ ...pe(), ...jr(e) }), P(tt, pe());
    const t = on();
    t.text && _(ai, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function di() {
  ge.set(!1);
}
const Zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Xa,
  hasShineEffect: ei,
  isEnabled: ti,
  isLoaderVisible: ni,
  isMounted: ge,
  isVisible: ri,
  mount: ci,
  offClick: pi,
  onClick: ui,
  setParams: li,
  state: on,
  text: oi,
  textColor: si,
  unmount: di
}, Symbol.toStringTag, { value: "Module" }));
function an() {
  throw new p(
    qs,
    "CSS variables are already bound"
  );
}
function _i(e) {
  return Uo()(e);
}
const nt = "themeParams", Ur = "theme_changed", fi = U(nt), mi = Ze(nt, be), hi = mi(
  "bindCssVars",
  (e) => {
    je() && an(), e || (e = (r) => `--tg-theme-${Lt(r)}`);
    function t(r) {
      Object.entries($()).forEach(([o, s]) => {
        s && r(o, s);
      });
    }
    function n() {
      t((r, o) => {
        Vt(e(r), o);
      });
    }
    return n(), $.sub(n), je.set(!0), () => {
      t(Nt), $.unsub(n), je.set(!1);
    };
  }
), $r = fi("mount", () => {
  be() || (w(Ur, Fr), $.set(
    x() && k(nt) || Y().themeParams
  ), be.set(!0));
}), Fr = (e) => {
  const t = _i(e.theme_params);
  $.set(t), P(nt, t);
};
function bi() {
  C(Ur, Fr), be.set(!1);
}
// @__NO_SIDE_EFFECTS__
function Hr(e) {
  return /* @__PURE__ */ d(() => {
    const t = e();
    return _e(t) ? t : t === "bg_color" ? nn() : He();
  });
}
const we = /* @__PURE__ */ c("bg_color"), cn = /* @__PURE__ */ Hr(we), ye = /* @__PURE__ */ c("bottom_bar_bg_color"), un = /* @__PURE__ */ d(() => {
  const e = ye();
  return _e(e) ? e : e === "bottom_bar_bg_color" ? Nr() || He() : e === "secondary_bg_color" ? He() : nn();
}), Se = /* @__PURE__ */ c("bg_color"), Wr = /* @__PURE__ */ Hr(Se), Ee = /* @__PURE__ */ c(!1), Le = /* @__PURE__ */ c(!1), gi = /* @__PURE__ */ d(() => {
  const e = cn();
  return e ? Lr(e) : !1;
}), rt = /* @__PURE__ */ c(!0), zr = /* @__PURE__ */ d(() => ({
  backgroundColor: we(),
  bottomBarColor: ye(),
  headerColor: Se(),
  isActive: rt()
})), Pt = "web_app_set_background_color", kt = "web_app_set_bottom_bar_color", Ve = "web_app_set_header_color", Gr = "visibility_changed", ke = "miniApp", pn = {
  any: [
    Pt,
    kt,
    Ve
  ]
}, wi = /* @__PURE__ */ d(() => pn.any.some((e) => J(e, V()))), Jr = U(ke), yi = I(ke, pn), ot = Q(ke, Ee, pn), Si = ot(
  "bindCssVars",
  (e) => {
    Le() && an();
    const [t, n] = ne();
    function r(o, s) {
      function a() {
        Vt(o, s() || null);
      }
      a(), t(s.sub(a), Nt.bind(null, o));
    }
    return e || (e = (o) => `--tg-${Lt(o)}`), r(e("bgColor"), cn), r(e("bottomBarColor"), un), r(e("headerColor"), Wr), t(() => {
      Le.set(!1);
    }), Le.set(!0), n;
  }
), Ei = Jr("close", (e) => {
  _("web_app_close", { return_back: e });
}), Yr = (e) => {
  rt.set(e.is_visible), st();
}, vi = yi(
  "mount",
  () => {
    if (!Ee()) {
      const e = x() && k(ke);
      $r(), Qr.ifAvailable(e ? e.backgroundColor : "bg_color"), Kr.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), Zr.ifAvailable(e ? e.headerColor : "bg_color"), rt.set(e ? e.isActive : !0), w(Gr, Yr), Ee.set(!0);
    }
  }
), Ai = Jr("ready", () => {
  _("web_app_ready");
});
function st() {
  P(ke, zr());
}
const Qr = ot(
  "setBackgroundColor",
  (e) => {
    e !== we() && (_(Pt, { color: e }), we.set(e), st());
  },
  Pt
), Kr = ot(
  "setBottomBarColor",
  (e) => {
    e !== ye() && (_(kt, { color: e }), ye.set(e), st());
  },
  kt
), Zr = ot(
  "setHeaderColor",
  (e) => {
    e !== Se() && (_(Ve, _e(e) ? { color: e } : { color_key: e }), Se.set(e), st());
  },
  Ve,
  {
    rgb: [Ve, "color", _e]
  }
);
function Ci() {
  C(Gr, Yr), Ee.set(!1);
}
const Xc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: we,
  backgroundColorRGB: cn,
  bindCssVars: Si,
  bottomBarColor: ye,
  bottomBarColorRGB: un,
  close: Ei,
  headerColor: Se,
  headerColorRGB: Wr,
  isActive: rt,
  isCssVarsBound: Le,
  isDark: gi,
  isMounted: Ee,
  isSupported: wi,
  mount: vi,
  ready: Ai,
  setBackgroundColor: Qr,
  setBottomBarColor: Kr,
  setHeaderColor: Zr,
  state: zr,
  unmount: Ci
}, Symbol.toStringTag, { value: "Module" }));
function Ri(e) {
  const t = e.message.trim(), n = (e.title || "").trim(), r = e.buttons || [];
  if (n.length > 64)
    throw new p(ce, `Invalid title: ${n}`);
  if (!t || t.length > 256)
    throw new p(ce, `Invalid message: ${t}`);
  if (r.length > 3)
    throw new p(ce, `Invalid buttons count: ${r.length}`);
  return {
    title: n,
    message: t,
    buttons: r.length ? r.map((o, s) => {
      const a = o.id || "";
      if (a.length > 64)
        throw new p(ce, `Button with index ${s} has invalid id: ${a}`);
      if (!o.type || o.type === "default" || o.type === "destructive") {
        const i = o.text.trim();
        if (!i || i.length > 64)
          throw new p(ce, `Button with index ${s} has invalid text: ${i}`);
        return { type: o.type, text: i, id: a };
      }
      return { type: o.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
const ln = "web_app_open_popup", Ti = I("popup", ln), Ne = /* @__PURE__ */ c(!1), Bi = M(ln), Pi = Ti(
  "open",
  async (e) => {
    if (Ne())
      throw new p(Wt, "A popup is already opened");
    Ne.set(!0);
    try {
      const { button_id: t = null } = await E(ln, "popup_closed", {
        ...e,
        params: Ri(e)
      });
      return t;
    } finally {
      Ne.set(!1);
    }
  }
), eu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: Ne,
  isSupported: Bi,
  open: Pi
}, Symbol.toStringTag, { value: "Module" })), ki = "web_app_close_scan_qr_popup", dn = "web_app_open_scan_qr_popup", Ii = "scan_qr_popup_closed", Oi = "qr_text_received", Xr = I("qrScanner", dn), It = Xr("close", () => {
  ee.set(!1), _(ki);
}), ee = /* @__PURE__ */ c(!1), Di = M(dn);
function xi(e) {
  return b.withFn((t) => {
    if (ee())
      throw new p(Wt, "The QR Scanner is already opened");
    ee.set(!0), e || (e = {});
    const { onCaptured: n, text: r, capture: o } = e, [, s] = ne(
      // Whenever the scanner was closed for some reason (by a developer or a
      // user), we should resolve the promise with undefined.
      ee.sub(() => {
        a.resolve();
      }),
      // Whenever user closed the scanner, update the isOpened signal state.
      w(Ii, () => {
        ee.set(!1);
      }),
      // Whenever some QR was scanned, we should check if it must be captured.
      w(Oi, (i) => {
        n ? n(i.data) : (!o || o(i.data)) && (a.resolve(i.data), It());
      })
    ), a = new is({ abortSignal: t }).catch(It).finally(s);
    return (e.postEvent || _)(dn, { text: r }), a;
  }, e);
}
const Mi = Xr("open", xi), tu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: It,
  isOpened: ee,
  isSupported: Di,
  open: Mi
}, Symbol.toStringTag, { value: "Module" }));
function H(e) {
  return /* @__PURE__ */ d(() => _n()[e]);
}
const le = /* @__PURE__ */ c({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  position: "left",
  text: "Cancel"
}), _n = /* @__PURE__ */ d(() => {
  const e = le();
  return {
    ...e,
    backgroundColor: e.backgroundColor || un() || "#000000",
    textColor: e.textColor || rn() || "#2481cc"
  };
}), ve = /* @__PURE__ */ c(!1), ji = H("backgroundColor"), Li = H("hasShineEffect"), Vi = H("isEnabled"), Ni = H("isLoaderVisible"), qi = H("isVisible"), Ui = H("position"), $i = H("text"), Fi = H("textColor"), at = "web_app_setup_secondary_button", eo = "secondary_button_pressed", it = "secondaryButton", fn = I(it, at), Hi = Q(it, ve, at), Wi = M(at), zi = fn("mount", () => {
  if (!ve()) {
    const e = x() && k(it);
    e && le.set(e), ve.set(!0);
  }
}), Gi = fn(
  "onClick",
  (e) => w(eo, e)
), Ji = fn(
  "offClick",
  (e) => {
    C(eo, e);
  }
), Yi = Hi(
  "setParams",
  (e) => {
    le.set({
      ...le(),
      ...Object.fromEntries(
        Object.entries(e).filter(([, n]) => n !== void 0)
      )
    }), P(it, le());
    const t = _n();
    t.text && _(at, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      position: t.position,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function Qi() {
  ve.set(!1);
}
const nu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: ji,
  hasShineEffect: Li,
  isEnabled: Vi,
  isLoaderVisible: Ni,
  isMounted: ve,
  isSupported: Wi,
  isVisible: qi,
  mount: zi,
  offClick: Ji,
  onClick: Gi,
  position: Ui,
  setParams: Yi,
  state: _n,
  text: $i,
  textColor: Fi,
  unmount: Qi
}, Symbol.toStringTag, { value: "Module" })), ct = "web_app_setup_settings_button", to = "settings_button_pressed", ut = "settingsButton", Ot = /* @__PURE__ */ c(!1), Ae = /* @__PURE__ */ c(!1), Ki = M(ct), mn = I(ut, ct), no = Q(ut, Ae, ct), Zi = no("hide", () => {
  hn(!1);
}), Xi = mn("mount", () => {
  Ae() || (hn(x() && k(ut) || !1), Ae.set(!0));
});
function hn(e) {
  e !== Ot() && (_(ct, { is_visible: e }), P(ut, e), Ot.set(e));
}
const ec = mn(
  "onClick",
  (e) => w(to, e)
), tc = mn(
  "offClick",
  (e) => {
    C(to, e);
  }
), nc = no("show", () => {
  hn(!0);
});
function rc() {
  Ae.set(!1);
}
const ru = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: Zi,
  isMounted: Ae,
  isSupported: Ki,
  isVisible: Ot,
  mount: Xi,
  offClick: tc,
  onClick: ec,
  show: nc,
  unmount: rc
}, Symbol.toStringTag, { value: "Module" })), pt = "web_app_setup_swipe_behavior", lt = "swipeBehavior", Ce = /* @__PURE__ */ c(!1), oc = M(pt), Dt = /* @__PURE__ */ c(!0), sc = I(lt, pt), ro = Q(lt, Ce, pt), ac = ro("disableVertical", () => {
  bn(!1);
}), ic = ro("enableVertical", () => {
  bn(!0);
}), cc = sc("mount", () => {
  Ce() || (bn(
    x() && k(lt) || !1,
    !0
  ), Ce.set(!0));
});
function bn(e, t) {
  (e !== Dt() || t) && (_(pt, { allow_vertical_swipe: e }), P(lt, e), Dt.set(e));
}
function uc() {
  Ce.set(!1);
}
const ou = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableVertical: ac,
  enableVertical: ic,
  isMounted: Ce,
  isSupported: oc,
  isVerticalEnabled: Dt,
  mount: cc,
  unmount: uc
}, Symbol.toStringTag, { value: "Module" })), su = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accentTextColor: $a,
  backgroundColor: nn,
  bindCssVars: hi,
  bottomBarBgColor: Nr,
  buttonColor: rn,
  buttonTextColor: Vr,
  destructiveTextColor: Fa,
  headerBackgroundColor: Ha,
  hintColor: Wa,
  isCssVarsBound: je,
  isDark: za,
  isMounted: be,
  linkColor: Ga,
  mount: $r,
  secondaryBackgroundColor: He,
  sectionBackgroundColor: Ja,
  sectionHeaderTextColor: Ya,
  sectionSeparatorColor: Qa,
  state: $,
  subtitleTextColor: Ka,
  textColor: Za,
  unmount: bi
}, Symbol.toStringTag, { value: "Module" })), se = "viewport", oo = "web_app_request_fullscreen", pc = "fullscreen_failed", gn = "fullscreen_changed", so = "safe_area_changed", ao = "content_safe_area_changed", io = "viewport_changed", jn = "web_app_request_safe_area", Ln = "web_app_request_content_safe_area", Vn = {
  left: 0,
  top: 0,
  bottom: 0,
  right: 0
};
function wt(e) {
  return Math.max(e, 0);
}
const de = /* @__PURE__ */ c({
  contentSafeAreaInsets: Vn,
  height: 0,
  isExpanded: !1,
  isFullscreen: !1,
  safeAreaInsets: Vn,
  stableHeight: 0,
  width: 0
});
function Z(e) {
  return /* @__PURE__ */ d(() => de()[e]);
}
function ae(e) {
  const { height: t, stableHeight: n, width: r } = e;
  de.set({
    ...de(),
    ...jr({
      ...e,
      height: t ? wt(t) : void 0,
      width: r ? wt(r) : void 0,
      stableHeight: n ? wt(n) : void 0
    })
  }), P(se, de());
}
function lc() {
  return k(se);
}
const co = Z("isFullscreen"), wn = /* @__PURE__ */ c(), dc = /* @__PURE__ */ d(() => !!wn()), uo = /* @__PURE__ */ c(), Ie = /* @__PURE__ */ c(!1), _c = /* @__PURE__ */ d(() => !!dt()), po = /* @__PURE__ */ c(void 0), dt = /* @__PURE__ */ c(), fc = Q(se, Ie, oo);
function lo(e, t) {
  return fc(e, /* @__PURE__ */ Be(
    (n) => E(t, [gn, pc], n).then((r) => {
      if ("error" in r) {
        if (r.error === "ALREADY_FULLSCREEN")
          return !0;
        throw new p(Hs, "Fullscreen request failed", r.error);
      }
      return r.is_fullscreen;
    }).then((r) => {
      r !== co() && ae({ isFullscreen: r });
    }),
    () => new p(F, "Fullscreen mode change is already being requested"),
    wn,
    uo
  ));
}
const mc = lo("requestFullscreen", oo), hc = lo("exitFullscreen", "web_app_exit_fullscreen"), _o = U(se), bc = Ze(se, Ie);
function _t(e) {
  return /* @__PURE__ */ d(() => yn()[e]);
}
const yn = Z("safeAreaInsets"), fo = _t("bottom"), mo = _t("left"), ho = _t("right"), bo = _t("top");
function ft(e) {
  return /* @__PURE__ */ d(() => Sn()[e]);
}
const Sn = Z("contentSafeAreaInsets"), go = ft("bottom"), wo = ft("left"), yo = ft("right"), So = ft("top"), gc = /* @__PURE__ */ h(
  "requestContentSafeAreaInsets",
  (e) => E(Ln, "content_safe_area_changed", e),
  { isSupported: Ln }
), wc = /* @__PURE__ */ h(
  "requestSafeAreaInsets",
  (e) => E(jn, "safe_area_changed", e),
  { isSupported: jn }
);
function yc(e) {
  return E("web_app_request_viewport", "viewport_changed", e).then((t) => ({
    height: t.height,
    width: t.width,
    isExpanded: t.is_expanded,
    isStable: t.is_state_stable
  }));
}
const Eo = (e) => {
  const { height: t } = e;
  ae({
    isExpanded: e.is_expanded,
    height: t,
    width: e.width,
    stableHeight: e.is_state_stable ? t : void 0
  });
}, vo = (e) => {
  ae({ isFullscreen: e.is_fullscreen });
}, Ao = (e) => {
  ae({ safeAreaInsets: e });
}, Co = (e) => {
  ae({ contentSafeAreaInsets: e });
}, Sc = _o("mount", /* @__PURE__ */ Rr(
  se,
  (e) => b.resolve().then(async () => {
    const t = x() && lc();
    if (t)
      return t;
    const [
      n,
      r
    ] = await b.all([
      wc.ifAvailable(e) || yn(),
      gc.ifAvailable(e) || Sn()
    ]), o = Y(), s = {
      contentSafeAreaInsets: r,
      isFullscreen: !!o.fullscreen,
      safeAreaInsets: n
    };
    if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(o.platform)) {
      const a = window;
      return {
        ...s,
        height: a.innerHeight,
        isExpanded: !0,
        stableHeight: a.innerHeight,
        width: a.innerWidth
      };
    }
    return yc(e).then((a) => ({
      ...s,
      height: a.height,
      isExpanded: a.isExpanded,
      stableHeight: a.isStable ? a.height : 0,
      width: a.width
    }));
  }),
  (e) => {
    w(io, Eo), w(gn, vo), w(so, Ao), w(ao, Co), ae(e);
  },
  Ie,
  dt,
  po
));
function Ec() {
  const e = dt();
  e && e.cancel(), C(io, Eo), C(gn, vo), C(so, Ao), C(ao, Co), Ie.set(!1);
}
const qe = /* @__PURE__ */ c(!1), En = Z("height"), vn = Z("stableHeight"), Ro = Z("width"), vc = bc(
  "bindCssVars",
  (e) => {
    qe() && an(), e || (e = (n) => `--tg-viewport-${Lt(n)}`);
    const t = [
      ["height", En],
      ["stableHeight", vn],
      ["width", Ro],
      ["safeAreaInsetTop", bo],
      ["safeAreaInsetBottom", fo],
      ["safeAreaInsetLeft", mo],
      ["safeAreaInsetRight", ho],
      ["contentSafeAreaInsetTop", So],
      ["contentSafeAreaInsetBottom", go],
      ["contentSafeAreaInsetLeft", wo],
      ["contentSafeAreaInsetRight", yo]
    ].reduce((n, [r, o]) => {
      const s = e(r);
      if (s) {
        const a = () => {
          Vt(s, `${o()}px`);
        };
        n.push([a, o.sub(a), s]);
      }
      return n;
    }, []);
    return t.forEach((n) => {
      n[0]();
    }), qe.set(!0), () => {
      t.forEach((n) => {
        n[1](), Nt(n[2]);
      }), qe.set(!1);
    };
  }
), Ac = _o("expand", () => {
  _("web_app_expand");
}), Cc = Z("isExpanded"), Rc = /* @__PURE__ */ d(() => En() === vn()), au = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCssVars: vc,
  changeFullscreenError: uo,
  changeFullscreenPromise: wn,
  contentSafeAreaInsetBottom: go,
  contentSafeAreaInsetLeft: wo,
  contentSafeAreaInsetRight: yo,
  contentSafeAreaInsetTop: So,
  contentSafeAreaInsets: Sn,
  exitFullscreen: hc,
  expand: Ac,
  height: En,
  isChangingFullscreen: dc,
  isCssVarsBound: qe,
  isExpanded: Cc,
  isFullscreen: co,
  isMounted: Ie,
  isMounting: _c,
  isStable: Rc,
  mount: Sc,
  mountError: po,
  mountPromise: dt,
  requestFullscreen: mc,
  safeAreaInsetBottom: fo,
  safeAreaInsetLeft: mo,
  safeAreaInsetRight: ho,
  safeAreaInsetTop: bo,
  safeAreaInsets: yn,
  stableHeight: vn,
  state: de,
  unmount: Ec,
  width: Ro
}, Symbol.toStringTag, { value: "Module" })), Nn = "web_app_request_emoji_status_access", To = /* @__PURE__ */ c(), Tc = /* @__PURE__ */ c(), iu = /* @__PURE__ */ d(() => !!To()), cu = /* @__PURE__ */ h(
  "requestEmojiStatusAccess",
  /* @__PURE__ */ Be(
    () => E(Nn, "emoji_status_access_requested").then((e) => e.status),
    () => new p(
      F,
      "Emoji status access request is currently in progress"
    ),
    To,
    Tc,
    !1
  ),
  { isSupported: Nn }
), qn = "web_app_set_emoji_status", Bo = /* @__PURE__ */ c(), Bc = /* @__PURE__ */ c(), uu = /* @__PURE__ */ d(() => !!Bo()), pu = /* @__PURE__ */ h(
  "setEmojiStatus",
  /* @__PURE__ */ Be(
    async (e, t) => {
      const n = await E(qn, ["emoji_status_set", "emoji_status_failed"], {
        params: {
          custom_emoji_id: e,
          duration: t
        }
      });
      if (n && "error" in n)
        throw new p(Ws, "Failed to set emoji status", n.error);
    },
    () => new p(
      F,
      "Emoji status set request is currently in progress"
    ),
    Bo,
    Bc,
    !1
  ),
  { isSupported: qn }
), Po = "web_app_add_to_home_screen", ie = { isSupported: Po }, ko = /* @__PURE__ */ c(), Pc = /* @__PURE__ */ c(), lu = /* @__PURE__ */ d(() => !!ko()), du = /* @__PURE__ */ h(
  "addToHomeScreen",
  () => {
    _(Po);
  },
  ie
), _u = /* @__PURE__ */ h(
  "checkHomeScreenStatus",
  /* @__PURE__ */ Be(
    (e) => E("web_app_check_home_screen", "home_screen_checked", e).then((t) => t.status || "unknown"),
    () => new p(
      F,
      "Check home screen status request is currently in progress"
    ),
    ko,
    Pc
  ),
  ie
), fu = /* @__PURE__ */ h(
  "onAddedToHomeScreen",
  (e, t) => w("home_screen_added", e, t),
  ie
), mu = /* @__PURE__ */ h(
  "onAddToHomeScreenFailed",
  (e, t) => w("home_screen_failed", e, t),
  ie
), hu = /* @__PURE__ */ h(
  "offAddedToHomeScreen",
  (e) => {
    C("home_screen_added", e);
  },
  ie
), bu = /* @__PURE__ */ h(
  "offAddToHomeScreenFailed",
  (e) => {
    C("home_screen_failed", e);
  },
  ie
), kc = U(), gu = kc(
  "openLink",
  (e, t) => {
    if (typeof e == "string")
      try {
        e = new URL(e);
      } catch (n) {
        throw new p(Ht, `"${e.toString()}" is invalid URL`, n);
      }
    t || (t = {}), _("web_app_open_link", {
      url: e.toString(),
      try_browser: t.tryBrowser,
      try_instant_view: t.tryInstantView
    });
  }
), Un = "web_app_open_tg_link", Ic = U(), Oc = Ic(
  "openTelegramLink",
  (e) => {
    const t = e.toString();
    if (!t.match(/^https:\/\/t.me\/.+/))
      throw new p(Ht, `"${t}" is invalid URL`);
    if (!J(Un, V())) {
      window.location.href = t;
      return;
    }
    e = new URL(e), _(Un, { path_full: e.pathname + e.search });
  }
), Dc = U(), wu = Dc(
  "shareURL",
  (e, t) => {
    Oc(
      "https://t.me/share/url?" + new URLSearchParams({ url: e, text: t || "" }).toString().replace(/\+/g, "%20")
    );
  }
), xt = "web_app_request_phone", yt = /* @__PURE__ */ c(!1), xc = /* @__PURE__ */ h(
  "requestPhoneAccess",
  (e) => {
    if (yt())
      throw new p(F, "Phone access request is currently in progress");
    return yt.set(!0), E(xt, "phone_requested", e).then((t) => t.status).finally(() => {
      yt.set(!1);
    });
  },
  {
    isSupported: xt
  }
);
function $n(e) {
  return e || (e = {}), oe("getRequestedContact", {}, {
    ...e,
    timeout: e.timeout || 5e3
  }).then(
    Kn({
      contact: Ue({
        userId: ["user_id", $e()],
        phoneNumber: ["phone_number", N()],
        firstName: ["first_name", N()],
        lastName: ["last_name", N(!0)]
      })(),
      authDate: ["auth_date", Mt()],
      hash: N()
    })()
  );
}
const yu = /* @__PURE__ */ h(
  "requestContact",
  (e) => b.withFn(
    async (t) => {
      const n = { abortSignal: t };
      try {
        return await $n(n);
      } catch {
      }
      if (await xc(n) !== "sent")
        throw new p(Vs, "User denied access");
      let r = 50;
      for (; !t.aborted; ) {
        try {
          return await $n(n);
        } catch {
        }
        await cs(r), r += 50;
      }
      return null;
    },
    e
  ),
  {
    isSupported: xt
  }
), Fn = "web_app_request_write_access", St = /* @__PURE__ */ c(!1), Su = /* @__PURE__ */ h(
  "requestWriteAccess",
  (e) => {
    if (St())
      throw new p(F, "Write access request is currently in progress");
    return St.set(!0), E(Fn, "write_access_requested", e).then((t) => t.status).finally(() => {
      St.set(!1);
    });
  },
  {
    isSupported: Fn
  }
), Eu = /* @__PURE__ */ h(
  "getCurrentTime",
  (e) => oe("getCurrentTime", {}, e).then(Mt()),
  {
    isSupported: "web_app_invoke_custom_method"
  }
), Hn = "web_app_read_text_from_clipboard", vu = /* @__PURE__ */ h(
  "readTextFromClipboard",
  (e) => {
    const t = vr();
    return E(Hn, "clipboard_text_received", {
      ...e,
      params: { req_id: t },
      capture: Sr(t)
    }).then(({ data: n = null }) => n);
  },
  {
    isSupported: Hn
  }
), Au = /* @__PURE__ */ h(
  "sendData",
  (e) => {
    const { size: t } = new Blob([e]);
    if (!t || t > 4096)
      throw new p(Ls, t ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    _("web_app_data_send", { data: e });
  }
), Wn = "web_app_share_to_story", Cu = /* @__PURE__ */ h(
  "shareStory",
  (e, t) => {
    t || (t = {}), _(Wn, {
      text: t.text,
      media_url: e,
      widget_link: t.widgetLink
    });
  },
  { isSupported: Wn }
), zn = "web_app_switch_inline_query", Ru = /* @__PURE__ */ h(
  "switchInlineQuery",
  (e, t) => {
    _(zn, {
      query: e,
      chat_types: t || []
    });
  },
  {
    isSupported: [zn, {
      fn: () => !!Y().botInline,
      error: "Mini App should be ran in Bot inline mode"
    }]
  }
);
function Tu(e) {
  try {
    return { result: e() };
  } catch (t) {
    return { error: t };
  }
}
function Bu(e) {
  Ms(e), Rs();
  const [t, n] = ne(
    w("reload_iframe", () => {
      _("iframe_will_reload"), window.location.reload();
    }),
    Ts
  ), { acceptCustomStyles: r = !0 } = e || {};
  if (r) {
    const o = document.createElement("style");
    o.id = "telegram-custom-styles", document.head.appendChild(o), t(
      w("set_custom_style", (s) => {
        o.innerHTML = s;
      }),
      () => {
        document.head.removeChild(o);
      }
    );
  }
  return _("iframe_ready", { reload_supported: !0 }), n;
}
function Pu() {
  return Io(Y, []);
}
function ku(e) {
  return Oo((t) => e.sub(t), e);
}
export {
  xs as $createRequestId,
  ds as $debug,
  Er as $postEvent,
  ys as $targetOrigin,
  V as $version,
  b as CancelablePromise,
  lr as ERR_ABORTED,
  Vs as ERR_ACCESS_DENIED,
  Ns as ERR_ALREADY_MOUNTING,
  Wt as ERR_ALREADY_OPENED,
  F as ERR_ALREADY_REQUESTING,
  dr as ERR_CANCELED,
  qs as ERR_CSS_VARS_ALREADY_BOUND,
  ws as ERR_CUSTOM_METHOD_ERR_RESPONSE,
  Ls as ERR_DATA_INVALID_SIZE,
  Ws as ERR_EMOJI_STATUS_SET_FAILED,
  Hs as ERR_FULLSCREEN_FAILED,
  js as ERR_INVALID_SLUG,
  Ht as ERR_INVALID_URL,
  xo as ERR_INVALID_VALUE,
  gs as ERR_METHOD_PARAMETER_UNSUPPORTED,
  hs as ERR_METHOD_UNSUPPORTED,
  Us as ERR_NOT_AVAILABLE,
  $s as ERR_NOT_INITIALIZED,
  Fs as ERR_NOT_MOUNTED,
  Dn as ERR_NOT_SUPPORTED,
  Jn as ERR_PARSE,
  ce as ERR_POPUP_INVALID_PARAMS,
  bs as ERR_RETRIEVE_LP_FAILED,
  _r as ERR_TIMED_OUT,
  jo as ERR_UNEXPECTED_TYPE,
  Mo as ERR_UNEXPECTED_VALUE,
  br as ERR_UNKNOWN_ENV,
  p as TypedError,
  pr as addEventListener,
  du as addToHomeScreen,
  ca as authenticateBiometry,
  Hc as backButton,
  Si as bindMiniAppCssVars,
  hi as bindThemeParamsCssVars,
  vc as bindViewportCssVars,
  Wc as biometry,
  Tr as biometryMountError,
  Je as biometryState,
  uo as changeFullscreenError,
  wn as changeFullscreenPromise,
  _u as checkHomeScreenStatus,
  Pc as checkHomeScreenStatusError,
  ko as checkHomeScreenStatusPromise,
  Et as classNames,
  Ei as closeMiniApp,
  It as closeQrScanner,
  zc as closingBehavior,
  Gc as cloudStorage,
  Bs as compareVersions,
  Ps as createPostEvent,
  Rs as defineEventHandlers,
  ya as deleteCloudStorageItem,
  Nt as deleteCssVar,
  ma as disableClosingConfirmation,
  ac as disableVerticalSwipes,
  Ct as emitMiniAppsEvent,
  ha as enableClosingConfirmation,
  ic as enableVerticalSwipes,
  hc as exitFullscreen,
  Ac as expandViewport,
  Ea as getCloudStorageItem,
  va as getCloudStorageKeys,
  Eu as getCurrentTime,
  Jc as hapticFeedback,
  Ra as hapticFeedbackImpactOccurred,
  Ta as hapticFeedbackNotificationOccurred,
  Ba as hapticFeedbackSelectionChanged,
  Gs as hideBackButton,
  Zi as hideSettingsButton,
  Bu as init,
  Yc as initData,
  Or as initDataAuthDate,
  Dr as initDataCanSendAfter,
  Pa as initDataCanSendAfterDate,
  ka as initDataChat,
  Oa as initDataChatInstance,
  Ia as initDataChatType,
  Da as initDataHash,
  xa as initDataQueryId,
  xr as initDataRaw,
  Ma as initDataReceiver,
  La as initDataStartParam,
  en as initDataState,
  Va as initDataUser,
  Kc as invoice,
  ks as invokeCustomMethod,
  Nc as isAbortError,
  De as isAuthenticatingBiometry,
  me as isBackButtonMounted,
  zs as isBackButtonSupported,
  Tt as isBackButtonVisible,
  Ye as isBiometryMounted,
  Xs as isBiometryMounting,
  sa as isBiometrySupported,
  qc as isCanceledError,
  dc as isChangingFullscreen,
  lu as isCheckingHomeScreenStatus,
  he as isClosingBehaviorMounted,
  Bt as isClosingConfirmationEnabled,
  wa as isCloudStorageSupported,
  Lr as isColorDark,
  co as isFullscreen,
  Ca as isHapticFeedbackSupported,
  rs as isIframe,
  Me as isInvoiceOpened,
  qa as isInvoiceSupported,
  ti as isMainButtonEnabled,
  ni as isMainButtonLoaderVisible,
  ge as isMainButtonMounted,
  ri as isMainButtonVisible,
  rt as isMiniAppActive,
  Le as isMiniAppCssVarsBound,
  gi as isMiniAppDark,
  Ee as isMiniAppMounted,
  wi as isMiniAppSupported,
  Ne as isPopupOpened,
  Bi as isPopupSupported,
  ee as isQrScannerOpened,
  Di as isQrScannerSupported,
  _e as isRGB,
  No as isRGBShort,
  Xn as isRecord,
  xe as isRequestingBiometryAccess,
  iu as isRequestingEmojiStatusAccess,
  yt as isRequestingPhoneAccess,
  St as isRequestingWriteAccess,
  xn as isSSR,
  Vi as isSecondaryButtonEnabled,
  Ni as isSecondaryButtonLoaderVisible,
  ve as isSecondaryButtonMounted,
  Wi as isSecondaryButtonSupported,
  qi as isSecondaryButtonVisible,
  uu as isSettingEmojiStatus,
  Ae as isSettingsButtonMounted,
  Ki as isSettingsButtonSupported,
  Ot as isSettingsButtonVisible,
  Ce as isSwipeBehaviorMounted,
  oc as isSwipeBehaviorSupported,
  In as isTMA,
  je as isThemeParamsCssVarsBound,
  za as isThemeParamsDark,
  be as isThemeParamsMounted,
  Vc as isTimeoutError,
  Dt as isVerticalSwipesEnabled,
  qe as isViewportCssVarsBound,
  Cc as isViewportExpanded,
  Ie as isViewportMounted,
  _c as isViewportMounting,
  Rc as isViewportStable,
  Zc as mainButton,
  Xa as mainButtonBackgroundColor,
  ei as mainButtonHasShineEffect,
  on as mainButtonState,
  oi as mainButtonText,
  si as mainButtonTextColor,
  Lc as mergeClassNames,
  Xc as miniApp,
  we as miniAppBackgroundColor,
  cn as miniAppBackgroundColorRGB,
  ye as miniAppBottomBarColor,
  un as miniAppBottomBarColorRGB,
  Se as miniAppHeaderColor,
  Wr as miniAppHeaderColorRGB,
  Ai as miniAppReady,
  zr as miniAppState,
  Uc as mockTelegramEnv,
  Js as mountBackButton,
  la as mountBiometry,
  ba as mountClosingBehavior,
  ci as mountMainButton,
  vi as mountMiniApp,
  zi as mountSecondaryButton,
  Xi as mountSettingsButton,
  cc as mountSwipeBehavior,
  $r as mountThemeParams,
  Sc as mountViewport,
  C as off,
  bu as offAddToHomeScreenFailed,
  hu as offAddedToHomeScreen,
  Qs as offBackButtonClick,
  pi as offMainButtonClick,
  Ji as offSecondaryButtonClick,
  tc as offSettingsButtonClick,
  w as on,
  mu as onAddToHomeScreenFailed,
  fu as onAddedToHomeScreen,
  Ys as onBackButtonClick,
  ui as onMainButtonClick,
  Gi as onSecondaryButtonClick,
  ec as onSettingsButtonClick,
  ua as openBiometrySettings,
  Ua as openInvoice,
  gu as openLink,
  Pi as openPopup,
  Mi as openQrScanner,
  Oc as openTelegramLink,
  Qc as parseInitData,
  _i as parseThemeParams,
  eu as popup,
  Ut as postEvent,
  tu as qrScanner,
  vu as readTextFromClipboard,
  Ts as removeEventHandlers,
  $t as request,
  ta as requestBiometry,
  pa as requestBiometryAccess,
  yu as requestContact,
  gc as requestContentSafeAreaInsets,
  cu as requestEmojiStatusAccess,
  Tc as requestEmojiStatusAccessError,
  To as requestEmojiStatusAccessPromise,
  mc as requestFullscreen,
  xc as requestPhoneAccess,
  wc as requestSafeAreaInsets,
  yc as requestViewport,
  Su as requestWriteAccess,
  ja as restoreInitData,
  Y as retrieveLaunchParams,
  Tu as safeCall,
  nu as secondaryButton,
  ji as secondaryButtonBackgroundColor,
  Li as secondaryButtonHasShineEffect,
  Ui as secondaryButtonPosition,
  _n as secondaryButtonState,
  $i as secondaryButtonText,
  Fi as secondaryButtonTextColor,
  Au as sendData,
  jc as serializeLaunchParams,
  Cn as serializeThemeParams,
  Aa as setCloudStorageItem,
  Vt as setCssVar,
  pu as setEmojiStatus,
  Bc as setEmojiStatusError,
  Bo as setEmojiStatusPromise,
  li as setMainButtonParams,
  Qr as setMiniAppBackgroundColor,
  Kr as setMiniAppBottomBarColor,
  Zr as setMiniAppHeaderColor,
  Yi as setSecondaryButtonParams,
  ru as settingsButton,
  Cu as shareStory,
  wu as shareURL,
  Ks as showBackButton,
  nc as showSettingsButton,
  $c as subscribe,
  J as supports,
  ou as swipeBehavior,
  Ru as switchInlineQuery,
  su as themeParams,
  $a as themeParamsAccentTextColor,
  nn as themeParamsBackgroundColor,
  Nr as themeParamsBottomBarBgColor,
  rn as themeParamsButtonColor,
  Vr as themeParamsButtonTextColor,
  Fa as themeParamsDestructiveTextColor,
  Ha as themeParamsHeaderBackgroundColor,
  Wa as themeParamsHintColor,
  Ga as themeParamsLinkColor,
  He as themeParamsSecondaryBackgroundColor,
  Ja as themeParamsSectionBackgroundColor,
  Ya as themeParamsSectionHeaderTextColor,
  Qa as themeParamsSectionSeparatorColor,
  $ as themeParamsState,
  Ka as themeParamsSubtitleTextColor,
  Za as themeParamsTextColor,
  Zn as toRGB,
  Qn as toRecord,
  Zs as unmountBackButton,
  da as unmountBiometry,
  ga as unmountClosingBehavior,
  di as unmountMainButton,
  Ci as unmountMiniApp,
  Qi as unmountSecondaryButton,
  rc as unmountSettingsButton,
  uc as unmountSwipeBehavior,
  bi as unmountThemeParams,
  Ec as unmountViewport,
  Fc as unsubscribe,
  _a as updateBiometryToken,
  Pu as useLaunchParams,
  ku as useSignal,
  au as viewport,
  go as viewportContentSafeAreaInsetBottom,
  wo as viewportContentSafeAreaInsetLeft,
  yo as viewportContentSafeAreaInsetRight,
  So as viewportContentSafeAreaInsetTop,
  Sn as viewportContentSafeAreaInsets,
  En as viewportHeight,
  po as viewportMountError,
  dt as viewportMountPromise,
  fo as viewportSafeAreaInsetBottom,
  mo as viewportSafeAreaInsetLeft,
  ho as viewportSafeAreaInsetRight,
  bo as viewportSafeAreaInsetTop,
  yn as viewportSafeAreaInsets,
  vn as viewportStableHeight,
  de as viewportState,
  Ro as viewportWidth
};
//# sourceMappingURL=index.js.map
